package application

import (
	"fmt"

	"github.com/felixgeelhaar/roady/pkg/domain"
	"github.com/felixgeelhaar/roady/pkg/domain/planning"
	"github.com/felixgeelhaar/roady/pkg/domain/spec"
)

type InitService struct {
	repo     domain.WorkspaceRepository
	audit    domain.AuditLogger
	template string // optional template name
}

func NewInitService(repo domain.WorkspaceRepository, audit domain.AuditLogger) *InitService {
	return &InitService{repo: repo, audit: audit}
}

// SetTemplate sets the template to use for project initialization.
func (s *InitService) SetTemplate(name string) {
	s.template = name
}

func (s *InitService) buildSpec(projectName string) *spec.ProductSpec {
	if s.template != "" {
		if tmpl := FindTemplate(s.template); tmpl != nil {
			return tmpl.Spec(projectName)
		}
	}
	// Default minimal spec
	return &spec.ProductSpec{
		ID:          projectName,
		Title:       projectName,
		Description: "Initial product specification generated by roady.",
		Version:     "0.1.0",
		Features: []spec.Feature{
			{
				ID:          "core-foundation",
				Title:       "Core Foundation",
				Description: "The essential building blocks of the project.",
			},
		},
	}
}

func (s *InitService) InitializeProject(name string) error {
	if s.repo.IsInitialized() {
		return fmt.Errorf("project already initialized")
	}

	if err := s.repo.Initialize(); err != nil {
		return err
	}

	if err := s.audit.Log("project.initialized", "cli", map[string]interface{}{
		"project_name": name,
	}); err != nil {
		// Log but don't fail init? Or fail? TDD says audit is critical.
		return fmt.Errorf("failed to write audit log: %w", err)
	}

	// Create spec from template or default skeleton
	defaultSpec := s.buildSpec(name)

	if err := s.repo.SaveSpec(defaultSpec); err != nil {
		return err
	}

	if err := s.repo.SaveSpecLock(defaultSpec); err != nil {
		return err
	}

	// Create a default policy
	defaultPolicy := &domain.PolicyConfig{
		MaxWIP:  3,
		AllowAI: true,
	}
	if err := s.repo.SavePolicy(defaultPolicy); err != nil {
		return err
	}

	// Initialize Execution State
	initialState := planning.NewExecutionState(name)
	if err := s.repo.SaveState(initialState); err != nil {
		return err
	}

	return s.repo.UpdateUsage(domain.UsageStats{})
}
